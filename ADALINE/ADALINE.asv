clc;
format long

p = readmatrix('input_p.txt');
t = readmatrix('output_t.txt');
global maxE;
global alpha;

e =0;
allErrors = [];
numerillosAux = [];

% Función de pérdida
function j = J(y, ypred)
    j = (y - ypred)^2;
end

% LMS
function [w, b] = LMS(W, B, p, alpha, e)
    w = W + 2 * alpha * e * p';
    b = B + 2 * alpha * e;
end

% Purelin
function a = purelin(W, p, b)
    a = W * p';
    return
end

global epoch
epoch = 100;  

function erroresEpoca= regresor()
    disp("Preparando regresor");
    global epoch;
    maxE = 0.000001;
    alpha  = 0.3;
    erroresEpoca = [];
    epocas = [];
    error=0;
    W = rand(1, 3);  
    list = [];
    kEpoch=[];
    k=1;
    r = input("Agregue el número de bits: ");
    
   
    for i = 1:2^r
        numerillo = dec2bin(i - 1, r); 
        list = [list; numerillo];
    end

    numMatrix = double(list) - double('0');
    list = numMatrix;  
    W=[];
    for letra = 1:r
        W = [W, rand];
    end
    errAux = 0;
    aux = 0;

    while aux < epoch
        for peso = 1:size(list, 1)
            p = list(peso, :);
            
            
            a = purelin(W, p, [0; 0; 0]);
            if a == 0
                continue
            end
           
            t= peso-1;
            e = (t-a)^2;
            errAux =+e;
            
            for i = 1:length(W)
                W(i) = W(i) + (2*alpha*(t-a)*p(i));
                try
                    file = fopen("pesos.txt", "a");
                    if file == -1
                        error("No se pudo abrir el archivo.");
                    end
                    disp(W(i))
                    fprintf(file, "%f\n", W(i));
                    fclose(file);

                catch ME
                    disp("No se pudo abrir el archivo");
                    disp(ME.message);
                end
                i=i+3;
            end
            
            if (isnan(e) ==1)
                break
            end
            if(t==7)
                error = errAux/size(list,1);
                erroresEpoca =[erroresEpoca; error];
                epocas = [epocas;aux+1];
            end
        k=k+1
        kEpoch = [kEpoch, k];
        end
        aux = aux + 1;

    if (error < maxE && t==7)
        disp("Correcto!")
        disp("Número de épocas: ")
        disp(aux)
        
        break
    end

    end

file = fopen("pesos.txt", "r"); % Abrir el archivo en modo de lectura

if file == -1
    error("No se pudo abrir el archivo.");
end
    pesos =[];
    % Inicializar listas para almacenar los pesos
    peso1 = [];
    peso2 = [];
    peso3 = [];
    counter = 1; % Contador para asignar valores de forma cíclica
    
    try
    while ~feof(file)
        line = strtrim(fgets(file)); 

        if contains(line, "=") 
            parts = split(line, "=");
            value = str2double(strtrim(parts{2})); 
        elseif ~isempty(line)
            value = str2double(line); 
        else
            continue;
        end
        pesos(end+1) = value;
        end
    catch ME
        disp("Error al leer el archivo:");
        disp(ME.message);
    end
    
    fclose(file); 
    
    peso1 = [];
    peso2 = [];
    peso3 = [];
    
    % Asignar valores cíclicamente a las listas
    for i = 1:3:length(pesos)
        if i <= length(pesos)
            peso1(end+1) = pesos(i); % Primer peso
        end
        if i+1 <= length(pesos)
            peso2(end+1) = pesos(i+1);
        end
        if i+2 <= length(pesos)
            peso3(end+1) = pesos(i+2); 
        end
    end
    
    hold on
    subplot(2,1,1)
    plot(epocas,erroresEpoca), 
    legend('Error cuadrático medio')
    xlabel('Épocas'), ylabel('Errores')
    title('Gráfica de errores para el entrenamiento de ADALINE en modo regresor')
    subplot(2,1,2)
    plot(kEpoch,peso1, "filled", l)
    legend('Actualización de pesos por iteración');
    xlabel('Pesos 1'), ylabel('t');
    title('Actualizaciones de pesos para el entrenamiento de ADALINE en modo regresor');
    subplot(2,1,2)
    scatter(kEpoch,peso2,"filled")
    legend('Actualización de pesos por iteración');
    xlabel('Pesos'), ylabel('t');
    title('Actualizaciones de pesos para el entrenamiento de ADALINE en modo regresor');
    subplot(2,1,2)
    plot(kEpoch,peso3, "filled")
    legend('Actualización de pesos por iteración');
    xlabel('Pesos'), ylabel('t');
    title('Actualizaciones de pesos para el entrenamiento de ADALINE en modo regresor');
    hold of
    % % Verificar los tamaños de las listas
    % disp("Tamaño de peso1: ");
    % disp(peso1(1));
    % disp("Tamaño de peso2: ");
    % disp(peso2(1));
    % disp("Tamaño de peso3: ");
    % disp(peso3(1));
    %     % Verificar los tamaños de las listas
    % disp("Tamaño de peso1: ");
    % disp(peso1(2));
    % disp("Tamaño de peso2: ");
    % disp(peso2(2));
    % disp("Tamaño de peso3: ");
    % disp(peso3(2));
    %     disp("Tamaño de peso1: ");
    % disp(peso1(3));
    % disp("Tamaño de peso2: ");
    % disp(peso2(3));
    % disp("Tamaño de peso3: ");
    % disp(peso3(3));
    %     % Verificar los tamaños de las listas
    % disp("Tamaño de peso1: ");
    % disp(peso1(4));
    % disp("Tamaño de peso2: ");
    % disp(peso2(4));
    % disp("Tamaño de peso3: ");
    % disp(peso3(4));
    % try
    %     while ~feof(file)
    %         line = strtrim(fgets(file)); % Leer línea y eliminar espacios en blanco
    % 
    % 
    %         if contains(line, "=") % Detectar líneas con formato "wX=valor"
    %             parts = split(line, "="); % Dividir la línea en clave y valor
    %             value = str2double(strtrim(parts{2})); % Convertir el valor a número
    %         elseif ~isempty(line) % Detectar líneas con solo números
    %             value = str2double(line); % Convertir a número
    %         else
    %             continue; % Ignorar líneas vacías
    %         end
    %         pesos(end+1) = value;
    %         % % Asignar valores cíclicamente a las listas
    %         % if mod(counter, 3) == 1
    %         %     peso1(end + 1) = value;
    %         % elseif mod(counter, 3) == 2
    %         %     peso2(end + 1) = value;
    %         % else
    %         %     peso3(end + 1) = value;
    %         % end
    %         % counter = counter + 3; % Incrementar el contador
    %     end
    % catch ME
    %     disp("Error al leer el archivo:");
    %     disp(ME.message);
    % end
    % 
    % fclose(file); % Cerrar el archivo
    % 
    % % Mostrar las listas
    % disp("Pesos:");
    % disp(pesos);
    % % disp("Peso2:");
    % % disp(peso2);
    % % disp("Peso3:");
    % % disp(peso3);
    % i=1;
    % for a = 1:size(pesos)
    %     disp(a)
    %     peso1(end+1) = pesos(i);
    %     peso2(end+1) = pesos(i+1);
    %     peso3(end+1) = pesos(i+2);
    %     a=a+3;
    %     i=i+3;
    % end
    % 
    % hold on
    % disp(size(k))
    % disp(peso1(1))
    % disp(peso2(1))
    % disp(peso3(1))
    % disp(peso1(2))
    % disp(peso2(2))
    % disp(peso3(2))
    % stem(k,peso1)
    % stem(k,peso2)
    % stem(k,peso3)
    % legend('Actualización de pesos por iteración');
    % xlabel('Pesos'), ylabel('t');
    % title('Actualizaciones de pesos para el entrenamiento de ADALINE en modo regresor');
    %hold off

    return

end



% Clasificador
function clasificador()
    disp("Clasificador en construcción...");

    global epoch;
    maxE = 0.000001;
    alpha  = 0.3;
    erroresEpoca = [];
    epocas = [];
    error=0;
    W = rand(1, 3);  
    list = [];
    



end

% Adaline
function Adaline()
    disp("Adaline en construcción...");
end

% Menú principal
while true
    n = input("Para modo clasificador teclee 1\nPara modo regresor teclee 2\nPara salir escriba 0\n");
    
    switch n
        case 1
            disp("Ha elegido modo clasificador para ADALINE");
            clasificador();
        case 2
            disp("Ha elegido modo regresor para ADALINE");
            r = regresor();
            disp("Errores generados:");
            disp(r);
        case 0
            break
        otherwise
            disp("Por favor agregue un dato correcto");
    end
end

disp("Ha finalizado el programa.");